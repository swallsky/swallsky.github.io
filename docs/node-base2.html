<html lang="en"><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="favicon.ico"/><link rel="stylesheet" href="/highlight/styles/default.min.css"/><link href="css/node-base2.css" rel="stylesheet" type="text/css"/><title>码农魔法书 - Node.js基础</title><script type="text/javascript" src="js/global.js"></script></head><body style="margin:0;padding:0"><div id="root"><div style="display:none"><div class="sc-beySPh logPCA"><ul><li><a href="./">首页</a></li><li><a href="./go-base.html">Go语言</a></li><li><a href="./node-base.html">Node.js</a></li><li><a href="./ft-react-communication.html">前端</a></li></ul></div><div class="sc-guDLey jyIDhn"><div class="menu"><div class="title">Node.js基础</div><div><nav class="table-of-contents"><ol><li><a href="#node-js">Node.js  基础篇 </a><ol><li><a href="#repl">REPL(交互解释器) </a></li><li><a href="#">回调函数 </a></li><li><a href="#-1">事件驱动编程 </a><ol><li><a href="#event-emitter">EventEmitter </a></li><li><a href="#-2">事件循环 </a></li><li><a href="#-3">实例代码: </a><ol><li><a href="#-4">简单实例 </a></li><li><a href="#-5">多个事件处理 </a></li><li><a href="#-6">带参数的事件处理 </a></li><li><a href="#-7">监听器统计 </a></li><li><a href="#error">error事件 </a></li><li><a href="#event-emitter-1">继承EventEmitter </a></li></ol></li><li><a href="#-8">结语 </a></li></ol></li><li><a href="#buffer">Buffer(缓冲区) </a><ol><li><a href="#buffer-1">Buffer与字符串编码 </a></li><li><a href="#buffer-2">创建Buffer类 </a></li><li><a href="#-9">写入缓冲区 </a></li><li><a href="#-10">从缓冲区读取数据 </a></li><li><a href="#buffer-json">Buffer转换为JSON对象 </a></li><li><a href="#-11">缓冲区合并 </a></li><li><a href="#-12">缓冲区比较 </a></li><li><a href="#-13">拷贝缓冲区 </a></li><li><a href="#-14">缓冲区裁剪 </a></li><li><a href="#-15">缓冲区长度 </a></li></ol></li><li><a href="#stream">Stream(流) </a><ol><li><a href="#-16">从流中读取数据 </a></li><li><a href="#-17">写入流 </a></li><li><a href="#-18">管道流 </a></li><li><a href="#-19">链式流 </a></li></ol></li><li><a href="#-20">模块系统 </a><ol><li><a href="#-21">引入模块 </a></li><li><a href="#-22">对象模块 </a></li><li><a href="#-23">内置模块 </a></li><li><a href="#exports-module-exports">exports和module.exports </a></li></ol></li><li><a href="#and">全局对象&amp;全局变量 </a><ol><li><a href="#-24">自定义全局变量 </a></li><li><a href="#-25">内置全局对象与全局变量 </a></li></ol></li><li><a href="#-26">工具模块 </a><ol><li><a href="#util">util工具 </a></li><li><a href="#os">OS模块 </a></li><li><a href="#path">Path模块 </a></li></ol></li><li><a href="#http">http模块 </a><ol><li><a href="#url">获取URL路径 </a></li><li><a href="#url-1">获取url参数 </a></li><li><a href="#-27">基于事件驱动的路由实例 </a></li></ol></li><li><a href="#-28">文件系统 </a><ol><li><a href="#-29">异步和同步 </a></li><li><a href="#-30">打开文件 </a></li><li><a href="#-31">获取文件信息 </a></li><li><a href="#-32">写入文件 </a></li><li><a href="#-33">读取文件 </a></li><li><a href="#-34">关闭文件 </a></li><li><a href="#-35">截取文件 </a></li><li><a href="#-36">删除文件 </a></li><li><a href="#-37">创建目录 </a></li><li><a href="#-38">读取目录 </a></li><li><a href="#-39">删除目录 </a></li><li><a href="#-40">文件模块其他方法参考 </a></li></ol></li></ol></li></ol></nav></div></div><div class="cnt"><div><h2 id="node-js" tabindex="-1">Node.js  基础篇 <a class="header-anchor" href="#node-js">§</a></h2>
<h3 id="repl" tabindex="-1">REPL(交互解释器) <a class="header-anchor" href="#repl">§</a></h3>
<blockquote>
<p>Node.js REPL(Read Eval Print Loop: 交互解释器)类似Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>
<p>Node自带了交互式解释器，可以执行以下任务：</p>
</blockquote>
<ul>
<li>
<p>读取    读取用户输入，解析输入的Javascript数据结构并存储在内存中。</p>
</li>
<li>
<p>执行    执行输入的数据结构。</p>
</li>
<li>
<p>打印    输出结果。</p>
</li>
<li>
<p>循环    循环操作以上步骤到用户两次按ctrl+c按钮退出。</p>
</li>
</ul>
<p>打开终端，输入node,即可进入REPL交互解释器。</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node</span>
<span class="hljs-meta prompt_">&gt; </span><span class="language-bash">
</span></code></pre>
<p>这里就可以在&gt;后输入简单的表达式，回车来显示结果</p>
<p>例如：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node</span>
<span class="hljs-meta prompt_">&gt; </span><span class="language-bash">1+4</span>
5
</code></pre>
<h3 id="" tabindex="-1">回调函数 <a class="header-anchor" href="#">§</a></h3>
<blockquote>
<p>Node.js异步编程的直接体现就是回调。异步编程依托回调来实现，但不能说使用了回调后程序就是异步化了。</p>
<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>例如： 一边读取文件，一边执行其他的命令，在文件读取完成后，将文件内容作为回调函数的参数返回，这样在执行代码时就没有阻塞或等待文件I/O操作。这就大大提高了Node.js的性能，可以处理大量的并发请求。</p>
</blockquote>
<p>异步代码实例：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-comment">// 文件读取后，异步执行处理</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>){
    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
});
</code></pre>
<h3 id="-1" tabindex="-1">事件驱动编程 <a class="header-anchor" href="#-1">§</a></h3>
<blockquote>
<p>事件驱动编程是一种编程范式，其中程序的执行流程取决于事件的发生和处理。在传统的命令式编中，程序按照预定的顺序依次执行。而在事件驱动编程中，程序通过监听事件来相应的触发回调函数来执行。这种模式可以提高并发性和可扩展性，尤其适用于大量并发请求的情况。</p>
</blockquote>
<h4 id="event-emitter" tabindex="-1">EventEmitter <a class="header-anchor" href="#event-emitter">§</a></h4>
<blockquote>
<p>EventEmitter是Node.js中内置的一个核心模块。</p>
<p>Node.js所有的异步I/O操作在完成时都会发送一个事件到事件队列。</p>
<p>Node.js里面的许多对象都会分发事件：</p>
<ul>
<li>
<p>一个net.Server对象会在每次有新连接时触发一件事件。</p>
</li>
<li>
<p>一个fs.readStream对象会在文件被打开时触发一个事件。</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<p>所有这些产生事件的对象都是events.EventEmitter的实例。</p>
</blockquote>
<p>常用的方法：</p>
<ul>
<li>
<p>on(event, listener)：注册一个事件监听器，当事件被触发时执行回调函数。</p>
</li>
<li>
<p>emit(event, [args])：触发事件，并将可选参数传递给事件监听器。</p>
</li>
<li>
<p>removeListener(event, listener)：移除指定事件的监听器。</p>
</li>
<li>
<p>once(event, listener)：注册一个一次性的事件监听器，该监听器在触发一次后将被移除。</p>
</li>
</ul>
<h4 id="-2" tabindex="-1">事件循环 <a class="header-anchor" href="#-2">§</a></h4>
<blockquote>
<p>Node.js使用事件循环来管理事件的触发和回调函数的执行，事件循环是一个持续运行的进程，它等待事件的触发并调用相应的回调函数。</p>
</blockquote>
<blockquote>
<p>事件循环的主要组成部分：</p>
<ul>
<li>
<p>事件触发器（Event Triggers）：发射事件的对象，可以是 Node.js 的核心模块、自定义对象或第三方模块。</p>
</li>
<li>
<p>事件队列（Event Queue）：存储待处理事件的队列。当事件被触发时，相关的回调函数会被添加到事件队列中。</p>
</li>
<li>
<p>事件处理器（Event Handlers）：从事件队列中取出事件及其回调函数，并执行回调函数。</p>
</li>
<li>
<p>事件循环（Event Loop）：负责不断事件队列中获取事件，并将其分发给对应的事件处理器进行处理。</p>
</li>
</ul>
</blockquote>
<p>事件循环图如下：</p>
<p><img src="./imgs/event_loop.jpg" alt="" /></p>
<h4 id="-3" tabindex="-1">实例代码: <a class="header-anchor" href="#-3">§</a></h4>
<h5 id="-4" tabindex="-1">简单实例 <a class="header-anchor" href="#-4">§</a></h5>
<p>代码文件：event-emitter.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-comment">// 引入events内置模块</span>
<span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);
<span class="hljs-comment">// 创建一个eventEitter对象</span>
<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-comment">// 创建事件处理程序</span>
<span class="hljs-keyword">const</span> connectHandler = <span class="hljs-keyword">function</span> <span class="hljs-title function_">connected</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);
};

<span class="hljs-comment">// 绑定一个connect事件处理程序</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>,connectHandler);

<span class="hljs-comment">// 触发connect事件</span>
eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;connect&quot;</span>);
</code></pre>
<h5 id="-5" tabindex="-1">多个事件处理 <a class="header-anchor" href="#-5">§</a></h5>
<p>代码文件：event-emitter.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-comment">// 引入events内置模块</span>
<span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);
<span class="hljs-comment">// 创建一个eventEitter对象</span>
<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-comment">// 创建事件处理程序</span>
<span class="hljs-keyword">const</span> connectHandler = <span class="hljs-keyword">function</span> <span class="hljs-title function_">connected</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);

    <span class="hljs-comment">// 解发另一个数据获取处理事件</span>
    eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;data_received&quot;</span>);
};

<span class="hljs-comment">// 绑定一个connect事件处理程序</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>,connectHandler);

<span class="hljs-comment">// 使用匿名函数版定 data_received事件</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data_received&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据接收成功。&quot;</span>);
});

<span class="hljs-comment">// 触发connect事件</span>
eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;connect&quot;</span>);
</code></pre>
<h5 id="-6" tabindex="-1">带参数的事件处理 <a class="header-anchor" href="#-6">§</a></h5>
<p>代码文件：event-emitter-arg.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);
<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();

eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;someEvent&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">arg1,arg2</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1&quot;</span>,arg1,arg2);
});

eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;someEvent&quot;</span>,<span class="hljs-string">&quot;arg1参数&quot;</span>,<span class="hljs-string">&quot;arg2参数&quot;</span>);
</code></pre>
<h5 id="-7" tabindex="-1">监听器统计 <a class="header-anchor" href="#-7">§</a></h5>
<blockquote>
<p>如果为特定的事件添加超过设置的监听数量，则EventEmitter会报错，这有助于发现内存泄漏等问题。</p>
</blockquote>
<p>代码文件：event-emitter-count.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);
<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-comment">// 监听器 #1</span>
<span class="hljs-keyword">const</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;监听器 listener1&quot;</span>);
}

<span class="hljs-comment">// 监听器 #1</span>
<span class="hljs-keyword">const</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;监听器 listener2&quot;</span>);
}

<span class="hljs-comment">// 绑定 connect事件，处理函数为 listener1</span>
eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&quot;connect&quot;</span>,listener1);

<span class="hljs-comment">// 绑定 connect事件，处理函数为 listener2</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>,listener2);

<span class="hljs-comment">// 查看 connect 监听器数量</span>
<span class="hljs-keyword">const</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&quot;connect&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot;个监听器监听连接事件。&quot;</span>);

<span class="hljs-comment">// 触发 connect 事件</span>
eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;connect&quot;</span>);

<span class="hljs-comment">// 移除绑定的 listener1 函数</span>
eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&quot;connect&quot;</span>,listener1);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; listener1 已被移除，不再监听 &quot;</span>);

<span class="hljs-comment">// 触发 connect 事件</span>
eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;connect&quot;</span>);

<span class="hljs-comment">// 查看新的监听个数</span>
<span class="hljs-keyword">const</span> eventListeners2 = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&quot;connect&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners2 + <span class="hljs-string">&quot;个监听器监听连接事件。&quot;</span>);
</code></pre>
<h5 id="error" tabindex="-1">error事件 <a class="header-anchor" href="#error">§</a></h5>
<blockquote>
<p>EventEmitter定义了一个特殊的事件error，它包含了错误的语义，我们在遇到异常的时候通常会触发error事件。</p>
<p>当error事件被触发，EventEmitter规定如果没有响应的监听器，Node.js会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发error事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);
<span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();
emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;error&quot;</span>);
</code></pre>
<h5 id="event-emitter-1" tabindex="-1">继承EventEmitter <a class="header-anchor" href="#event-emitter-1">§</a></h5>
<blockquote>
<p>大多数时候我们不会直接使用EventEmitter，而是在对象中继承它。包括fs、net、http在内的，只要是支持事件响应的核心模块都是EventEmitter的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<ul>
<li>
<p>首先，具有某个实体功能的对象实现事件符合语义，事件的监听和发生应该是一个对象的方法。</p>
</li>
<li>
<p>其次JavaScript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。</p>
</li>
</ul>
</blockquote>
<p>代码实例：event-emitter-extends.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);

<span class="hljs-comment">// 继承 EventEmitter</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">EvtDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> {};

<span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvtDemo</span>();

myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;myEvent&quot;</span>,<span class="hljs-function">(<span class="hljs-params">args</span>)=&gt;</span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;事件被触发，参数为:&quot;</span>,args);
});

myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;myEvent&quot;</span>,<span class="hljs-string">&quot;Hello World&quot;</span>);
</code></pre>
<h4 id="-8" tabindex="-1">结语 <a class="header-anchor" href="#-8">§</a></h4>
<blockquote>
<p>通过深入了解Node.js的EventEmitter类及其事件处理机制，我们可以灵活地处理和触发事件，实现事件驱动的编程模型。EventEmitter类的方法和事件使得我们能够写出更加灵活和可扩展的代码，提高程序的可读性和可维护性。</p>
<p>让我们深入探索和应用Node.js的EventEmitter类，发挥事件驱动编程的威力，开发出更加高效和可靠的应用程序！</p>
</blockquote>
<h3 id="buffer" tabindex="-1">Buffer(缓冲区) <a class="header-anchor" href="#buffer">§</a></h3>
<blockquote>
<p>JavaScript语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在Node.js中，定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓冲区。</p>
<p>在Node.js中，Buffer类是随Node内核一起发布的核心库。Buffer库为Node.js带来了一种存储原始数据的方法，可以让Node.js处理二进制数据，每当需要在Node.js中处理I/O操作中移动的数据时，就有可能使用Buffer库。原始数据存储在Buffer类的实例中。一个Buffer类似于一个整数数组，但它对应于V8堆内存之外的一块原始内存。</p>
</blockquote>
<h4 id="buffer-1" tabindex="-1">Buffer与字符串编码 <a class="header-anchor" href="#buffer-1">§</a></h4>
<blockquote>
<p>Buffer实例一般用于表示编码字符的序列，比如UTF-8、UCS2、Base64、或十六进制编码的数据。通过使用显式的字符编码，就可以在Buffer实例与普通的JavaScript字符串之间进行相互转换。</p>
<p>Node.js 目前支持的字符编码包括：</p>
<ul>
<li>
<p><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p>
</li>
<li>
<p><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p>
</li>
<li>
<p><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p>
</li>
<li>
<p><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</p>
</li>
<li>
<p><strong>base64</strong> - Base64 编码。</p>
</li>
<li>
<p><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</p>
</li>
<li>
<p><strong>binary</strong> - <strong>latin1</strong> 的别名。</p>
</li>
<li>
<p><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</p>
</li>
</ul>
</blockquote>
<p>代码文件：buffer-string.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&#x27;ascii&#x27;</span>);
<span class="hljs-comment">// 输出十六进制</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>));
<span class="hljs-comment">// 输出 base64</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;base64&#x27;</span>));
</code></pre>
<h4 id="buffer-2" tabindex="-1">创建Buffer类 <a class="header-anchor" href="#buffer-2">§</a></h4>
<blockquote>
<p>Buffer提供了以下API来创建Buffer类：</p>
<ul>
<li>
<p><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
</li>
<li>
<p><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
</li>
<li>
<p><strong>Buffer.allocUnsafeSlow(size)</strong> 与allocUnsafe不同，会直接创建缓冲区，速度会比allocUnsafe慢</p>
</li>
<li>
<p><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>
</li>
<li>
<p><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
</li>
<li>
<p><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>
</li>
<li>
<p><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</p>
</li>
</ul>
</blockquote>
<p>代码示例：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-comment">// 创建一个长度为10，且用0填充的Buffer</span>
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);
<span class="hljs-comment">// Buffer类型 &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1);

<span class="hljs-comment">// 创建一个Buffer类，长度为10，且用01来填充</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2);

<span class="hljs-comment">// 创建一个长度为10，且未初始化的Buffer.</span>
<span class="hljs-comment">// 这个方法比调用 Buffer.alloc()更快，</span>
<span class="hljs-comment">// 但返回的Buffer实例可能包含旧数据</span>
<span class="hljs-comment">// 因此需要使用fill()或write()重写。</span>
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf3);

<span class="hljs-comment">// 创建一个包含 &lt;Buffer 01 02 03&gt; 的Buffer</span>
<span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf4);

<span class="hljs-comment">// 创建一个包含UTF-8字节 &lt;Buffer 74 65 73 74&gt; 的Buffer</span>
<span class="hljs-keyword">const</span> buf5 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;test&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf5);

<span class="hljs-comment">// 创建一个包含Latin-1字节 &lt;Buffer 74 65 73 74&gt; 的Buffer</span>
<span class="hljs-keyword">const</span> buf6 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;latin1&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf6);
</code></pre>
<h4 id="-9" tabindex="-1">写入缓冲区 <a class="header-anchor" href="#-9">§</a></h4>
<blockquote>
<p>写入Node缓冲区的语法如下:</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-title function_">write</span>(string[, offset[, length]][, encoding])
</code></pre>
<p>参数如下：</p>
<ul>
<li>
<p><strong>string</strong> - 写入缓冲区的字符串。</p>
</li>
<li>
<p><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</p>
</li>
<li>
<p><strong>length</strong> - 写入的字节数，默认为 buffer.length</p>
</li>
<li>
<p><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</p>
</li>
</ul>
<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>
<p>返回值</p>
<p>返回实际写入的大小。如果buffer空间不足，则只会写入部分字符串。</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">256</span>);
len = buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;hello wolrd&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入字节数：&quot;</span>+len);
</code></pre>
<h4 id="-10" tabindex="-1">从缓冲区读取数据 <a class="header-anchor" href="#-10">§</a></h4>
<blockquote>
<p>读取Node.js缓冲区数据的语法如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-title function_">toString</span>([encoding[, start[, end]]])
</code></pre>
<p>参数</p>
<ul>
<li>
<p><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</p>
</li>
<li>
<p><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</p>
</li>
<li>
<p><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</p>
</li>
</ul>
<p>返回值</p>
<p>解码缓冲区数据并使用指定的编码返回字符串。</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">26</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  buf[i] = i + <span class="hljs-number">97</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>));       <span class="hljs-comment">// 输出: abcdefghijklmnopqrstuvwxyz</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));   <span class="hljs-comment">//使用 &#x27;ascii&#x27; 编码, 并输出: abcde</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));    <span class="hljs-comment">// 使用 &#x27;utf8&#x27; 编码, 并输出: abcde</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-literal">undefined</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)); <span class="hljs-comment">// 使用默认的 &#x27;utf8&#x27; 编码, 并输出: abcde</span>
</code></pre>
<h4 id="buffer-json" tabindex="-1">Buffer转换为JSON对象 <a class="header-anchor" href="#buffer-json">§</a></h4>
<blockquote>
<p>将Node.js Buffer转换为JSON对象的函数语法如下：</p>
<p>当字符串一个Buffer实例时，JSON.stringify()会隐式地调用该toJSON()</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-title function_">toJSON</span>()
</code></pre>
<p>返回值： 返回JSON对象。</p>
</blockquote>
<p>代码实例：buffer-json.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-comment">// 将Buffer转换为JSON</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x3</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x5</span>]);
<span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(buf);
<span class="hljs-comment">// {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);

<span class="hljs-comment">// 将JSON转换为Buffer</span>
<span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json,<span class="hljs-function">(<span class="hljs-params">key,value</span>)=&gt;</span>{
    <span class="hljs-keyword">return</span> value &amp;&amp; value.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;Buffer&quot;</span>?<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(value.<span class="hljs-property">data</span>):value;
});
<span class="hljs-comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);
</code></pre>
<h4 id="-11" tabindex="-1">缓冲区合并 <a class="header-anchor" href="#-11">§</a></h4>
<blockquote>
<p>Node.js缓冲区合并的语法如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(list[, totalLength])
</code></pre>
<p>参数</p>
<ul>
<li>
<p><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</p>
</li>
<li>
<p><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</p>
</li>
</ul>
<p>返回值：返回一个多个成员合并的新Buffer对象。</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;Hello &quot;</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;World&quot;</span>);
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buf1,buf2]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;内容&quot;</span>+buf3.<span class="hljs-title function_">toString</span>());
</code></pre>
<h4 id="-12" tabindex="-1">缓冲区比较 <a class="header-anchor" href="#-12">§</a></h4>
<blockquote>
<p>Node Buffer比较的函数是在v0.12.2版本引入：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-title function_">compare</span>(otherBuffer);
</code></pre>
<p>参数：</p>
<ul>
<li><strong>otherBuffer</strong> - 与 <strong>buf</strong> 对象比较的另外一个 Buffer 对象。</li>
</ul>
<p>返顺值：返回一个数字，表示buf在otherBuffer之前，之后或相同。</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;ABC&quot;</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;ABCD&quot;</span>);
<span class="hljs-keyword">const</span> result = buf1.<span class="hljs-title function_">compare</span>(buf2);
<span class="hljs-comment">// -1 :buf1字符长度小于buf2，大于0时，buf1字符长度大于buf2，=0时，则两字符长度相同</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
</code></pre>
<h4 id="-13" tabindex="-1">拷贝缓冲区 <a class="header-anchor" href="#-13">§</a></h4>
<blockquote>
<p>Node.js缓冲区拷贝如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-title function_">copy</span>(targetBuffer[,targetStart[,sourceStart[, sourceEnd])
</code></pre>
<p>参数</p>
<ul>
<li>
<p><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</p>
</li>
<li>
<p><strong>targetStart</strong> - 数字, 可选, 默认: 0</p>
</li>
<li>
<p><strong>sourceStart</strong> - 数字, 可选, 默认: 0</p>
</li>
<li>
<p><strong>sourceEnd</strong> - 数字, 可选, 默认: buffer.length</p>
</li>
</ul>
<p>返回值： 没有返回值</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;abcdefg&quot;</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;hik&quot;</span>);
<span class="hljs-comment">//将buf2插入到buf1指定位置上</span>
buf2.<span class="hljs-title function_">copy</span>(buf1,<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1.<span class="hljs-title function_">toString</span>());
</code></pre>
<h4 id="-14" tabindex="-1">缓冲区裁剪 <a class="header-anchor" href="#-14">§</a></h4>
<blockquote>
<p>Node.js缓冲区裁剪语法如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-title function_">slice</span>([start[,end])
</code></pre>
<p>参数</p>
<ul>
<li>
<p><strong>start</strong> - 数字, 可选, 默认: 0</p>
</li>
<li>
<p><strong>end</strong> - 数字, 可选, 默认: buffer.length</p>
</li>
</ul>
<p>返回值： 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引start到end的位置剪裁。</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);
<span class="hljs-comment">// 剪裁缓冲区</span>
<span class="hljs-keyword">const</span> buf2 = buf1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer2 content: &quot;</span> + buf2.<span class="hljs-title function_">toString</span>());
</code></pre>
<h4 id="-15" tabindex="-1">缓冲区长度 <a class="header-anchor" href="#-15">§</a></h4>
<blockquote>
<p>Node.js缓冲区长度计算：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">buf.<span class="hljs-property">length</span>;
</code></pre>
<p>返回值：返回Buffer对象所占据的内存长度。</p>
</blockquote>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;www.hello.com&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Buffer length: &quot;</span>+buf.<span class="hljs-property">length</span>);
</code></pre>
<h3 id="stream" tabindex="-1">Stream(流) <a class="header-anchor" href="#stream">§</a></h3>
<blockquote>
<p>Stream是一个抽象接口，Node中有很多对象实现了这个接口。例如，对http服务器发起请求的request对象就是一个Stream，还有stdout(标准输出)。</p>
<p>Stream有四种流类型：</p>
<ul>
<li>
<p><strong>Readable</strong> - 可读操作。</p>
</li>
<li>
<p><strong>Writable</strong> - 可写操作。</p>
</li>
<li>
<p><strong>Duplex</strong> - 可读可写操作。</p>
</li>
<li>
<p><strong>Transform</strong> - 操作被写入数据，然后读出结果。</p>
</li>
</ul>
<p>Stream对象都是EventEmitter的实例。常用的事件有：</p>
<ul>
<li>
<p><strong>data</strong> - 当有数据可读时触发。</p>
</li>
<li>
<p><strong>end</strong> - 没有更多的数据可读时触发。</p>
</li>
<li>
<p><strong>error</strong> - 在接收和写入过程中发生错误时触发。</p>
</li>
<li>
<p><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</p>
</li>
</ul>
</blockquote>
<h4 id="-16" tabindex="-1">从流中读取数据 <a class="header-anchor" href="#-16">§</a></h4>
<p>读取test.txt中内容，代码(stream-read.js)如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">var</span> data= <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-comment">// 创建可读流</span>
<span class="hljs-keyword">const</span> reader = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);
<span class="hljs-comment">// 设置编码为 utf8</span>
reader.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&quot;UTF8&quot;</span>);
<span class="hljs-comment">// 处理流事件 --&gt;data,end, and error</span>
reader.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>){
    data += chunk;
});
<span class="hljs-comment">// 流事件结束</span>
reader.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});
<span class="hljs-comment">// 错误处理</span>
reader.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);
});
</code></pre>
<h4 id="-17" tabindex="-1">写入流 <a class="header-anchor" href="#-17">§</a></h4>
<p>写入字符内容到output.txt，代码(stream-write.js)如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">const</span> data = <span class="hljs-string">&quot;www.nodejs.org的教程&quot;</span>;
<span class="hljs-comment">// 创建一个可以写入的流，写入到文件output.txt中</span>
<span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);
<span class="hljs-comment">// 使用utf8编码写入数据</span>
writeStream.<span class="hljs-title function_">write</span>(data,<span class="hljs-string">&#x27;UTF8&#x27;</span>);
<span class="hljs-comment">// 标记文件末尾</span>
writeStream.<span class="hljs-title function_">end</span>();
<span class="hljs-comment">// 处理流事件 --&gt; finish、error</span>
writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;finish&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入完成。&quot;</span>);
});
<span class="hljs-comment">// 流错误处理</span>
writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);
});
</code></pre>
<h4 id="-18" tabindex="-1">管道流 <a class="header-anchor" href="#-18">§</a></h4>
<blockquote>
<p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数拓并将数据传递到另外一个流中。</p>
<img title="" src="./imgs/pipe.png" alt="" width="230">
<p>如下图所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶，使得水从一个桶流入到另外一个桶里，这样就慢慢的实现了大文件的复制过程。</p>
</blockquote>
<p>代码(stream-pipe.js)如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-comment">// 创建一个可读流</span>
<span class="hljs-keyword">const</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);
<span class="hljs-comment">// 创建一个可写流</span>
<span class="hljs-keyword">const</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);
<span class="hljs-comment">// 管道读写操作 读取test.txt内容，并将内容写入到output.txt文件中</span>
readerStream.<span class="hljs-title function_">pipe</span>(writerStream);
</code></pre>
<h4 id="-19" tabindex="-1">链式流 <a class="header-anchor" href="#-19">§</a></h4>
<blockquote>
<p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>
<p>利用管道和链式来压缩文件和解压文件。</p>
</blockquote>
<p>压缩代码：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;zlib&quot;</span>);
<span class="hljs-comment">// 压缩 test.txt 为 test.txt.gz</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)
    .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())
    .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&quot;test.txt.gz&quot;</span>));
</code></pre>
<p>解压代码：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;zlib&quot;</span>);
<span class="hljs-comment">// 解压 test.txt.gz 为 test.txt</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&quot;test.txt.gz&quot;</span>)
    .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGunzip</span>())
    .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));
</code></pre>
<h3 id="-20" tabindex="-1">模块系统 <a class="header-anchor" href="#-20">§</a></h3>
<blockquote>
<p>模块是Node.js应用程序的基本组成部分，文件和模块是一一对应的。即一个Node.js文件就是一个模块，这个文件可能是JavaScript代码、JSON或者编译过的C/C++扩展等。</p>
</blockquote>
<h4 id="-21" tabindex="-1">引入模块 <a class="header-anchor" href="#-21">§</a></h4>
<p>mods/hello.js模块代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-built_in">exports</span>.<span class="hljs-property">world</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);
}
</code></pre>
<p>在mods/test.js中引入hello模块，代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./hello&quot;</span>);
hello.<span class="hljs-title function_">world</span>();
</code></pre>
<p>hello.js通过exports对象把world函数作为模块的访问接口，然后通过require(“./hello”)加载这个模块，即可直接访问exports对象的成员函数了。</p>
<h4 id="-22" tabindex="-1">对象模块 <a class="header-anchor" href="#-22">§</a></h4>
<p>如果希望把一个对象封装到模块中，格式如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">// TODO</span>
}
</code></pre>
<p>例如(mods/md-hello.js)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">var</span> name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thyName</span>){
        name = thyName;
    };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello &quot;</span>+name);
    };
};
</code></pre>
<p>在(mods/md-test.js)中引用：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./md-hello&quot;</span>);
<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>();
hello.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;By Modules&quot;</span>);
hello.<span class="hljs-title function_">sayHello</span>();
</code></pre>
<h4 id="-23" tabindex="-1">内置模块 <a class="header-anchor" href="#-23">§</a></h4>
<blockquote>
<p>Node.js的内置模块，例如http模块等，可以直接引用，只需将它返回值赋给一个本地变量。</p>
</blockquote>
<p>代码示例：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
...
http.<span class="hljs-title function_">createServer</span>(...);
</code></pre>
<p>Node.js的require方法中的文件查找策略如下：</p>
<p><img src="./imgs/nodejs-require.jpg" alt="" /></p>
<h4 id="exports-module-exports" tabindex="-1">exports和module.exports <a class="header-anchor" href="#exports-module-exports">§</a></h4>
<blockquote>
<p>如果要对外暴露属性或方法，就用exports就行，要暴露对象(类似class，包含很多属性和方法)，就用module.exports</p>
<p>不建议同时使用exports和module.exports。</p>
<p>如果先使用exports对外暴露属性或者方法，再使用module.exports暴露对象，会使得exports上暴露的属性或者方法失效。</p>
</blockquote>
<h3 id="and" tabindex="-1">全局对象&amp;全局变量 <a class="header-anchor" href="#and">§</a></h3>
<blockquote>
<p>JavaScript中有一个特殊的对象，称为全局对象，它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器的JavaScript中，通常window是全局对象，而Node.js中的全局对象是global，在ECMAScript 2020出现之后，全局变量是globalThis，在Node.js环境会自动切换成global,浏览器环境自动切换window非常方便。</p>
</blockquote>
<h4 id="-24" tabindex="-1">自定义全局变量 <a class="header-anchor" href="#-24">§</a></h4>
<p>main.js代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">globalThis.<span class="hljs-property">version</span> = <span class="hljs-number">2.0</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;hello.js&quot;</span>);
</code></pre>
<p>hello.js代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis.<span class="hljs-property">version</span>);
}
</code></pre>
<h4 id="-25" tabindex="-1">内置全局对象与全局变量 <a class="header-anchor" href="#-25">§</a></h4>
<p><strong>__filename</strong></p>
<blockquote>
<p>执行的脚本的文件名(输出 文件所在的绝对路径)。</p>
</blockquote>
<p><strong>__dirname</strong></p>
<blockquote>
<p>当前执行脚本所在的目录。</p>
</blockquote>
<p><strong>setTimeout(cb,ms)</strong></p>
<blockquote>
<p>在指定的毫秒数(ms)后执行执定的函数(cb)</p>
<p>参数说明</p>
<ul>
<li>
<p>cb 为要执行的回调函数</p>
</li>
<li>
<p>指定的毫秒ms</p>
</li>
</ul>
<p>setTimeout()只执行一次指定的函数</p>
</blockquote>
<p><strong>clearTimeout(t)</strong></p>
<blockquote>
<p>用于停止之前创建的定时器。</p>
<p>参数说明</p>
<ul>
<li>t 定时器返回的句柄</li>
</ul>
</blockquote>
<p>time.js代码实例：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printHello</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);
}
<span class="hljs-comment">// 两秒后执行</span>
<span class="hljs-keyword">let</span> t = <span class="hljs-built_in">setTimeout</span>(printHello,<span class="hljs-number">2000</span>);
<span class="hljs-comment">// 清除定时器</span>
<span class="hljs-built_in">clearTimeout</span>(t);
</code></pre>
<p><strong>setInterval(cb, ms)</strong></p>
<blockquote>
<p>与setTimeout不同是，这个方法会不停地调用函数，直到clearInterval()被调用或窗口被关闭。</p>
<p>参数同setTimeout</p>
</blockquote>
<p><strong>clearInterval(t)</strong></p>
<blockquote>
<p>清除setInterval定时器</p>
<ul>
<li>t setInterval定时器句柄</li>
</ul>
</blockquote>
<p><strong>console</strong></p>
<blockquote>
<p>console用于提供控制台标准输出，Node.js沿用浏览器的实施标准。</p>
<p><strong>console.log(data)</strong>  输出字符串，可接收若干参数。</p>
<p><strong><a href="http://console.info">console.info</a>(data)</strong> 与console.log差别不大，返回信息性消息。</p>
<p><strong>console.error(data)</strong> 输出错误信息。</p>
<p><strong>console.warn(data)</strong> 输出警告信息。</p>
<p><strong>console.dir(obj[,options])</strong> 用来对一个对象进行检查，并以易于阅读和打印的格式显示。</p>
<p><strong>console.trace(message[,…])</strong> 当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数加入console.trace就行。</p>
<p><strong>console.assert(value[,message][,…])</strong> 用于判断某个表达式或变量是否为真，接收两个参数，第一个参数和是表达式，第二个参数是字符串。只有当第一个参数为false,才会输出第二个参数，否则不会有任何结果。</p>
</blockquote>
<p><strong>process</strong></p>
<blockquote>
<p>process是一个全局变量，即global对象的属性。</p>
<p>它用于描述当前Node.js进程状态的对象，提供一个与操作系统的简单接口。</p>
</blockquote>
<p>事件方法：</p>
<blockquote>
<p>exit** 当进程准备退出时触发。</p>
<p><strong>beforeExit</strong> 当node清空事件循环，并且没有其他安排时触发这个事件。当没有进程安排时node退出，但是beforeExit的监听器可以异步调用，这样node就会继续执行。</p>
<p><strong>uncaughtException</strong> 当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监听器，默认的操作(打印堆栈跟踪信息并退出)就不会发生。</p>
<p><strong>Signal事件</strong> 当进程接收到信号时就触发。</p>
</blockquote>
<p>main.js代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;exit&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>){
    <span class="hljs-comment">// 不会执行</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;never&quot;</span>);
    },<span class="hljs-number">0</span>);

    <span class="hljs-comment">// 退出业务逻辑处理</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;退出代码：&quot;</span>,code);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行结束&quot;</span>);
</code></pre>
<p>执行main.js文件，结果如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">node main.js
程序执行结束
退出码
</code></pre>
<p><strong>常用属性或方法</strong></p>
<blockquote>
<p>stdout  标准输出流。</p>
<p>stderr   标准错误流。</p>
<p>stdin     标准输入流。</p>
<p>argv    返回命令行参数的数组。</p>
<p>execPath   返回执行当前脚本的 Node 二进制文件的绝对路径。</p>
<p>execArgv   返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</p>
<p>env     返回当前环境变量的对象。</p>
<p>exitCode   进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</p>
<p>version    Node 的版本。</p>
<p>cwd()  返回当前工作目录的路径。</p>
<p>pid      返回当前进程的PID(进程ID)。</p>
<p>title     进程名，默认值为&quot;node&quot;，可以自定义该值。</p>
<p>arch   当前 CPU 的架构：‘arm’、‘ia32’ 或者 ‘x64’。</p>
<p>platform   运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’。</p>
<p>exit([code])  退出当前的Node.js进程。您可以提供一个可选的退出码作为参数。</p>
</blockquote>
<p>代码(process-alt.js)如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-comment">// 输出到终端</span>
process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;Hello World!&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span>);
<span class="hljs-comment">// 通过参数读取</span>
process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val, index, array</span>) {
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index + <span class="hljs-string">&#x27;: &#x27;</span> + val);
});
<span class="hljs-comment">// 获取执行路径</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">execPath</span>);
<span class="hljs-comment">// 平台信息</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">platform</span>);
</code></pre>
<p>执行process-alt.js，结果如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node process-alt.js</span>
Hello World!
0: node
1: /web/www/node/process-alt.js
/usr/local/node/0.10.36/bin/node
darwin
</code></pre>
<h3 id="-26" tabindex="-1">工具模块 <a class="header-anchor" href="#-26">§</a></h3>
<h4 id="util" tabindex="-1">util工具 <a class="header-anchor" href="#util">§</a></h4>
<blockquote>
<p>util是一个Node.js核心模块，提供常用函数集合，用于弥补核心JavaScript的功能过于精简的不足。</p>
</blockquote>
<p><strong>util.isArray(object)</strong></p>
<p>给定的参数object是一个数组返回true，否则返回false。</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>);
util.<span class="hljs-title function_">isArray</span>([]); <span class="hljs-comment">// true</span>
util.<span class="hljs-title function_">isArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span>
util.<span class="hljs-title function_">isArray</span>({}); <span class="hljs-comment">//false</span>
</code></pre>
<p><strong>util.isRegExp(object)</strong></p>
<p>给定的参数object是一个正则表达式返回true，否则返回 flase。</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>);
util.<span class="hljs-title function_">isRegExp</span>(<span class="hljs-regexp">/some regexp/</span>); <span class="hljs-comment">// true</span>
util.<span class="hljs-title function_">isRegExp</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;another regexp&#x27;</span>); <span class="hljs-comment">// true</span>
util.<span class="hljs-title function_">isRegExp</span>({});  <span class="hljs-comment">// false</span>
</code></pre>
<p><strong>util.isDate(object)</strong></p>
<p>给定的参数object是一个日期返回true，否则返回false。</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>);
util.<span class="hljs-title function_">isDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// true</span>
util.<span class="hljs-title function_">isDate</span>(<span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// false (without &#x27;new&#x27; returns a String)</span>
util.<span class="hljs-title function_">isDate</span>({}); <span class="hljs-comment">// false</span>
</code></pre>
<h4 id="os" tabindex="-1">OS模块 <a class="header-anchor" href="#os">§</a></h4>
<blockquote>
<p>Node.js OS模块提供了一些基本的系统操作函数。通过以下方式引入模块：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;os&quot;</span>)
</code></pre>
<p>方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>os.tmpdir()</td>
<td>返回操作系统的默认临时文件夹。</td>
</tr>
<tr>
<td>os.endianness()</td>
<td>返回 CPU 的字节序，可能的是 “BE” 或 “LE”。</td>
</tr>
<tr>
<td>os.hostname()</td>
<td>返回操作系统的主机名。</td>
</tr>
<tr>
<td>os.type()</td>
<td>返回操作系统名</td>
</tr>
<tr>
<td>os.platform()</td>
<td>返回编译时的操作系统名</td>
</tr>
<tr>
<td>os.arch()</td>
<td>返回操作系统 CPU 架构，可能的值有 “x64”、“arm” 和 “ia32”。</td>
</tr>
<tr>
<td>os.release()</td>
<td>返回操作系统的发行版本。</td>
</tr>
<tr>
<td>os.uptime()</td>
<td>返回操作系统运行的时间，以秒为单位。</td>
</tr>
<tr>
<td>os.loadavg()</td>
<td>返回一个包含 1、5、15 分钟平均负载的数组。</td>
</tr>
<tr>
<td>os.totalmem()</td>
<td>返回系统内存总量，单位为字节。</td>
</tr>
<tr>
<td>os.freemem()</td>
<td>返回操作系统空闲内存量，单位是字节。</td>
</tr>
<tr>
<td>os.cpus()</td>
<td>返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。</td>
</tr>
<tr>
<td>os.networkInterfaces()</td>
<td>获得网络接口列表。</td>
</tr>
</tbody>
</table>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;os&quot;</span>);
<span class="hljs-comment">// CPU 的字节序</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;endianness : &#x27;</span> + os.<span class="hljs-title function_">endianness</span>());
<span class="hljs-comment">// 操作系统名</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;type : &#x27;</span> + os.<span class="hljs-title function_">type</span>());
<span class="hljs-comment">// 操作系统名</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;platform : &#x27;</span> + os.<span class="hljs-title function_">platform</span>());
<span class="hljs-comment">// 系统内存总量</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;total memory : &#x27;</span> + os.<span class="hljs-title function_">totalmem</span>() + <span class="hljs-string">&quot; bytes.&quot;</span>);
<span class="hljs-comment">// 操作系统空闲内存量</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;free memory : &#x27;</span> + os.<span class="hljs-title function_">freemem</span>() + <span class="hljs-string">&quot; bytes.&quot;</span>);
</code></pre>
<h4 id="path" tabindex="-1">Path模块 <a class="header-anchor" href="#path">§</a></h4>
<blockquote>
<p>Node.js path模块提供了一些用于处理文件路径的小工具，通过以下方式引入模块</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)
</code></pre>
<p><strong>属性：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>path.sep</td>
<td>平台的文件路径分隔符，‘\’ 或 ‘/’。</td>
</tr>
<tr>
<td>path.delimiter</td>
<td>平台的分隔符, ; or ‘:’.</td>
</tr>
<tr>
<td>path.posix</td>
<td>提供上述 path 的方法，不过总是以 posix 兼容的方式交互。</td>
</tr>
<tr>
<td>path.win32</td>
<td>提供上述 path 的方法，不过总是以 win32 兼容的方式交互。</td>
</tr>
</tbody>
</table>
<p><strong>方法：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>path.normalize(p)</td>
<td>输出规范格式的path字符串。</td>
</tr>
<tr>
<td>path.join([path1][, path2][, …])</td>
<td>用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是&quot;/“，Windows系统是”&quot;。</td>
</tr>
<tr>
<td>path.resolve([from …], to)</td>
<td>将 to 参数解析为绝对路径，给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve(‘/foo’, ‘/bar’, ‘baz’) 会返回 /bar/baz。</td>
</tr>
<tr>
<td>path.isAbsolute(path)</td>
<td>判断参数 path 是否是绝对路径。</td>
</tr>
<tr>
<td>path.relative(from, to)</td>
<td>用于将绝对路径转为相对路径，返回从 from 到 to 的相对路径（基于当前工作目录）。</td>
</tr>
<tr>
<td>path.dirname(p)</td>
<td>返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。</td>
</tr>
<tr>
<td>path.basename(p[, ext])</td>
<td>返回路径中的最后一部分。同 Unix 命令 bashname 类似。</td>
</tr>
<tr>
<td>path.extname(p)</td>
<td>返回路径中文件的后缀名，即路径中最后一个’.‘之后的部分。如果一个路径中并不包含’.‘或该路径只包含一个’.’ 且这个’.'为路径的第一个字符，则此命令返回空字符串。</td>
</tr>
<tr>
<td>path.parse(pathString)</td>
<td>返回路径字符串的对象。</td>
</tr>
<tr>
<td>path.format(pathObject)</td>
<td>从对象中返回路径字符串，和 path.parse 相反。</td>
</tr>
</tbody>
</table>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);
<span class="hljs-comment">// 格式化路径</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;normalization : &#x27;</span> + path.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&#x27;/test/test1//2slashes/1slash/tab/..&#x27;</span>));
<span class="hljs-comment">// 连接路径</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;joint path : &#x27;</span> + path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-string">&#x27;test1&#x27;</span>, <span class="hljs-string">&#x27;2slashes/1slash&#x27;</span>, <span class="hljs-string">&#x27;tab&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>));
<span class="hljs-comment">// 转换为绝对路径</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve : &#x27;</span> + path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;main.js&#x27;</span>));
<span class="hljs-comment">// 路径中文件的后缀名</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ext name : &#x27;</span> + path.<span class="hljs-title function_">extname</span>(<span class="hljs-string">&#x27;main.js&#x27;</span>));
</code></pre>
<h3 id="http" tabindex="-1">http模块 <a class="header-anchor" href="#http">§</a></h3>
<h4 id="url" tabindex="-1">获取URL路径 <a class="header-anchor" href="#url">§</a></h4>
<blockquote>
<p>获取URL路径，需要内置模块http,以及url模块，以下是代码实例</p>
</blockquote>
<p>代码文件：http-url.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;url&quot;</span>);
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    <span class="hljs-keyword">let</span> urls = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>);
    <span class="hljs-keyword">let</span> pathname = urls.<span class="hljs-property">pathname</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathname); <span class="hljs-comment">//打印URL路径</span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>,{<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span>});
    res.<span class="hljs-title function_">write</span>(pathname);
    res.<span class="hljs-title function_">end</span>();
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>);
</code></pre>
<p>命令行执行</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">node http-url.js
</code></pre>
<p>可通过浏览器访问<a href="http://localhost:8888/start%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E4%B8%BA/start%E3%80%82">http://localhost:8888/start，返回结果为/start。</a></p>
<h4 id="url-1" tabindex="-1">获取url参数 <a class="header-anchor" href="#url-1">§</a></h4>
<blockquote>
<p>获取url参数，需要内置模块querystring，以下是代码实例</p>
</blockquote>
<p>代码文件：http-query.js</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;url&quot;</span>);
<span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;querystring&quot;</span>);

http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    <span class="hljs-keyword">let</span> urls = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>);
    <span class="hljs-keyword">let</span> pathname = urls.<span class="hljs-property">pathname</span>;
    <span class="hljs-comment">// console.log(pathname);</span>
    <span class="hljs-keyword">let</span> params = querystring.<span class="hljs-title function_">parse</span>(urls.<span class="hljs-property">query</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params);
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>,{<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span>});
    res.<span class="hljs-title function_">write</span>(params);
    res.<span class="hljs-title function_">end</span>();
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>);
</code></pre>
<p>命令行执行</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">node http-query.js
</code></pre>
<p>可通过浏览器访问<a href="http://localhost:8888/start?foo=bar&amp;hello=world%EF%BC%8C%E5%8F%AF%E5%9C%A8%E5%91%BD%E4%BB%A4%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84">http://localhost:8888/start?foo=bar&amp;hello=world，可在命令下查看参数数组</a></p>
<h4 id="-27" tabindex="-1">基于事件驱动的路由实例 <a class="header-anchor" href="#-27">§</a></h4>
<blockquote>
<p>根据前面讲的EventEmitter事件驱动，我们可以写一个简单的web框架。</p>
</blockquote>
<p>代码(http-router.js)实例如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>);
<span class="hljs-comment">// 创建eventEmitter对象</span>
<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();
<span class="hljs-comment">// route 根路径</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">method,response</span>){
    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>,{<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>});
    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);
});
<span class="hljs-comment">// route 404</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;404&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">method,url,response</span>){
    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">404</span>,{<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>});
    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;404 Not Found&quot;</span>);
});
<span class="hljs-comment">//启动服务</span>
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">request,response</span>){
    <span class="hljs-comment">//打印当前的url</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">url</span>);
    <span class="hljs-comment">// 分发事件</span>
    <span class="hljs-keyword">if</span>(eventEmitter.<span class="hljs-title function_">listenerCount</span>(request.<span class="hljs-property">url</span>)&gt;<span class="hljs-number">0</span>){
        eventEmitter.<span class="hljs-title function_">emit</span>(request.<span class="hljs-property">url</span>,request.<span class="hljs-property">method</span>,response);
    }<span class="hljs-keyword">else</span>{
        eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;404&quot;</span>,request.<span class="hljs-property">method</span>,request.<span class="hljs-property">url</span>,response);
    }
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Server running at http://127.0.0.1:8000&quot;</span>);
</code></pre>
<p>命令行执行</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">node http-router.js
</code></pre>
<p>通过浏览器访问：</p>
<p><a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 返回结果: Hello World</p>
<p><a href="http://127.0.0.1:8000/not">http://127.0.0.1:8000/not</a> 返回结果：404 Not Found</p>
<h3 id="-28" tabindex="-1">文件系统 <a class="header-anchor" href="#-28">§</a></h3>
<blockquote>
<p>Node.js提供一组类似UNIX(POSIX)标准的文件操作API。Node导入文件系统模块fs语法如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
</code></pre>
</blockquote>
<h4 id="-29" tabindex="-1">异步和同步 <a class="header-anchor" href="#-29">§</a></h4>
<blockquote>
<p>Node.js文件系统(fs模块)模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。</p>
<p>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
</blockquote>
<p>实例file-demo1.js，代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-comment">// 异步读取</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>){
    <span class="hljs-keyword">if</span>(err){
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步读取：&quot;</span>+data.<span class="hljs-title function_">toString</span>());
});

<span class="hljs-comment">// 同步读取</span>
<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;同步读取： &quot;</span>+ data.<span class="hljs-title function_">toString</span>());
</code></pre>
<h4 id="-30" tabindex="-1">打开文件 <a class="header-anchor" href="#-30">§</a></h4>
<blockquote>
<p>语法如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">open</span>(path, flags[, mode], callback);
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li>
<p><strong>path</strong> - 文件的路径。</p>
</li>
<li>
<p><strong>flags</strong> - 文件打开的行为。</p>
</li>
<li>
<p><strong>mode</strong> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</p>
</li>
<li>
<p><strong>callback</strong> - 回调函数，带有两个参数如：callback(err, fd)。</p>
</li>
</ul>
<p><strong>flags</strong>参数说明</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>以读取模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td>r+</td>
<td>以读写模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td>rs</td>
<td>以同步的方式读取文件。</td>
</tr>
<tr>
<td>rs+</td>
<td>以同步的方式读取和写入文件。</td>
</tr>
<tr>
<td>w</td>
<td>以写入模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td>wx</td>
<td>类似w，但是如果文件路径存在，则文件写入失败。</td>
</tr>
<tr>
<td>w+</td>
<td>以读写模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td>wx+</td>
<td>类似w+，但是如果文件路径存在，则文件读写失败。</td>
</tr>
<tr>
<td>a</td>
<td>以追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td>ax</td>
<td>类似a，但是如果文件路径存在，则文件追加失败。</td>
</tr>
<tr>
<td>a+</td>
<td>以读取追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td>ax+</td>
<td>类似a+，但是如果文件路径存在，则文件读取追加失败。</td>
</tr>
</tbody>
</table>
</blockquote>
<p>实例file-demo2.js，代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-comment">// 异步打开文件</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;准备打开文件！&quot;</span>);
fs.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, fd</span>) {
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件打开成功！&quot;</span>);     
});
</code></pre>
<h4 id="-31" tabindex="-1">获取文件信息 <a class="header-anchor" href="#-31">§</a></h4>
<blockquote>
<p>语法如下：</p>
<p><strong>参数：</strong></p>
<ul>
<li>
<p><strong>path</strong> - 文件路径。</p>
</li>
<li>
<p><strong>callback</strong> - 回调函数，带有两个参数如：(err, stats), <strong>stats</strong> 是 fs.Stats 对象。</p>
</li>
</ul>
<p>fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中提供方法判断文件的相关属性。</p>
<p>例如判断是否为文件：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&quot;/var/www/fs.fs&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,stats</span>){
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stats.<span class="hljs-title function_">isFile</span>());  <span class="hljs-comment">// true </span>
});
</code></pre>
<p>stats类中的方法有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>stats.isFile()</td>
<td>如果是文件返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isDirectory()</td>
<td>如果是目录返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isBlockDevice()</td>
<td>如果是块设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isCharacterDevice()</td>
<td>如果是字符设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isSymbolicLink()</td>
<td>如果是软链接返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isFIFO()</td>
<td>如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
</tr>
<tr>
<td>stats.isSocket()</td>
<td>如果是 Socket 返回 true，否则返回 false。</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="-32" tabindex="-1">写入文件 <a class="header-anchor" href="#-32">§</a></h4>
<blockquote>
<p>语法</p>
<p>以下为异步模式下写入文件的语法格式：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">writeFile</span>(file,data[, options],callback)
</code></pre>
<p>writeFile直接打开文件，默认是w模式，所以如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
<p><strong>参数：</strong></p>
<p>参数使用说明如下：</p>
<ul>
<li>
<p><strong>file</strong> - 文件名或文件描述符。</p>
</li>
<li>
<p><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</p>
</li>
<li>
<p><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</p>
</li>
<li>
<p><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</p>
</li>
</ul>
</blockquote>
<p>实例代码：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>,  <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) {
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取写入的数据！&quot;</span>);
   fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) {
      <span class="hljs-keyword">if</span> (err) {
         <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步读取文件数据: &quot;</span> + data.<span class="hljs-title function_">toString</span>());
   });
});
</code></pre>
<h4 id="-33" tabindex="-1">读取文件 <a class="header-anchor" href="#-33">§</a></h4>
<blockquote>
<p>语法(以下为异步模式下读取文件的语法格式)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">read</span>(fd, buffer, offset, length, position, callback)
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li>
<p><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</p>
</li>
<li>
<p><strong>buffer</strong> - 数据写入的缓冲区。</p>
</li>
<li>
<p><strong>offset</strong> - 缓冲区写入的写入偏移量。</p>
</li>
<li>
<p><strong>length</strong> - 要从文件中读取的字节数。</p>
</li>
<li>
<p><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</p>
</li>
<li>
<p><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</p>
</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">let</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">1024</span>);
<span class="hljs-comment">// 准备打开已存在的文件</span>
fs.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, fd</span>) {
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-comment">// 准备读取文件内容</span>
   fs.<span class="hljs-title function_">read</span>(fd, buf, <span class="hljs-number">0</span>, buf.<span class="hljs-property">length</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, bytes</span>){
      <span class="hljs-keyword">if</span> (err){
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bytes + <span class="hljs-string">&quot;  字节被读取&quot;</span>);

      <span class="hljs-comment">// 仅输出读取的字节</span>
      <span class="hljs-keyword">if</span>(bytes &gt; <span class="hljs-number">0</span>){
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, bytes).<span class="hljs-title function_">toString</span>());
      }
   });
});
</code></pre>
<h4 id="-34" tabindex="-1">关闭文件 <a class="header-anchor" href="#-34">§</a></h4>
<blockquote>
<p>语法(以下为异步模式下关闭文件的语法格式)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">close</span>(fd,callback)
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">let</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">1024</span>);
<span class="hljs-comment">// 准备打开文件</span>
fs.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, fd</span>) {
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-comment">// 读取文件</span>
   fs.<span class="hljs-title function_">read</span>(fd, buf, <span class="hljs-number">0</span>, buf.<span class="hljs-property">length</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, bytes</span>){
      <span class="hljs-keyword">if</span> (err){
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
      }

      <span class="hljs-comment">// 仅输出读取的字节</span>
      <span class="hljs-keyword">if</span>(bytes &gt; <span class="hljs-number">0</span>){
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, bytes).<span class="hljs-title function_">toString</span>());
      }

      <span class="hljs-comment">// 关闭文件</span>
      fs.<span class="hljs-title function_">close</span>(fd, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
         <span class="hljs-keyword">if</span> (err){
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
         } 
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件关闭成功&quot;</span>);
      });
   });
});
</code></pre>
<h4 id="-35" tabindex="-1">截取文件 <a class="header-anchor" href="#-35">§</a></h4>
<blockquote>
<p>语法(以下为异步模式下截取文件的语法格式)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">ftruncate</span>(fd, len, callback)
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>len</strong> - 文件内容截取的长度。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-keyword">let</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">1024</span>);
<span class="hljs-comment">// 准备打开文件</span>
fs.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, fd</span>) {
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件打开成功！&quot;</span>);
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;截取10字节内的文件内容，超出部分将被去除。&quot;</span>);

   <span class="hljs-comment">// 截取文件</span>
   fs.<span class="hljs-title function_">ftruncate</span>(fd, <span class="hljs-number">10</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
      <span class="hljs-keyword">if</span> (err){
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
      } 
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件截取成功。&quot;</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取相同的文件&quot;</span>); 
      fs.<span class="hljs-title function_">read</span>(fd, buf, <span class="hljs-number">0</span>, buf.<span class="hljs-property">length</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, bytes</span>){
         <span class="hljs-keyword">if</span> (err){
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
         }

         <span class="hljs-comment">// 仅输出读取的字节</span>
         <span class="hljs-keyword">if</span>(bytes &gt; <span class="hljs-number">0</span>){
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, bytes).<span class="hljs-title function_">toString</span>());
         }

         <span class="hljs-comment">// 关闭文件</span>
         fs.<span class="hljs-title function_">close</span>(fd, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
            <span class="hljs-keyword">if</span> (err){
               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
            } 
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件关闭成功！&quot;</span>);
         });
      });
   });
});
</code></pre>
<h4 id="-36" tabindex="-1">删除文件 <a class="header-anchor" href="#-36">§</a></h4>
<blockquote>
<p>语法(以下为删除文件的语法格式)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">unlink</span>(path, callback)
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-comment">// &quot;准备删除文件！</span>
fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) {
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件删除成功！&quot;</span>);
});
</code></pre>
<h4 id="-37" tabindex="-1">创建目录 <a class="header-anchor" href="#-37">§</a></h4>
<blockquote>
<p>语法(以下为异步模式下的创建目录的格式)</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">mkdir</span>(path[, options],callback)
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li>
<p><strong>path</strong> - 文件路径。</p>
</li>
<li>
<p>options 参数可以是：</p>
<ul>
<li><strong>recursive</strong> - 是否以递归的方式创建目录，默认为 false。</li>
<li><strong>mode</strong> - 设置目录权限，默认为 0777。</li>
</ul>
</li>
<li>
<p><strong>callback</strong> - 回调函数，没有参数。</p>
</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-comment">// 创建/tmp/test目录</span>
fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&quot;/tmp/test/&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;目录创建成功。&quot;</span>);
});
</code></pre>
<h4 id="-38" tabindex="-1">读取目录 <a class="header-anchor" href="#-38">§</a></h4>
<blockquote>
<p>语法(以下为异步模式下的语法格式)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">readdir</span>(path, callback)
</code></pre>
<p><strong>参数</strong></p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-comment">// &quot;查看 /tmp 目录&quot;</span>
fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&quot;/tmp/&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err, files</span>){
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   files.<span class="hljs-title function_">forEach</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>){
       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( file );
   });
});
</code></pre>
<h4 id="-39" tabindex="-1">删除目录 <a class="header-anchor" href="#-39">§</a></h4>
<blockquote>
<p>语法(以下为异步模式下的删除目录语法格式)：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs">fs.<span class="hljs-title function_">rmdir</span>(path, callback)
</code></pre>
<p><strong>参数：</strong></p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
</blockquote>
<p>实例代码如下：</p>
<pre><div class="code-copy" onclick="CopyCode(this)">复制代码</div><code class="hljs"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);
<span class="hljs-comment">// 执行前创建一个空的 /tmp/test 目录</span>
fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&quot;/tmp/test&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
   <span class="hljs-keyword">if</span> (err) {
       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
   }
   <span class="hljs-comment">// 读取 /tmp 目录</span>
   fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&quot;/tmp/&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err, files</span>){
      <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
      }
      files.<span class="hljs-title function_">forEach</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>){
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( file );
      });
   });
});
</code></pre>
<h4 id="-40" tabindex="-1">文件模块其他方法参考 <a class="header-anchor" href="#-40">§</a></h4>
<blockquote>
<p>以下为Node.js文件模块其他方法列表：</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fs.rename(oldPath, newPath, callback)</td>
<td>异步 rename().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.ftruncate(fd, len, callback)</td>
<td>异步 ftruncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.ftruncateSync(fd, len)</td>
<td>同步的ftruncate()</td>
</tr>
<tr>
<td>fs.truncate(path, len, callback)</td>
<td>异步 truncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.truncateSync(path, len)</td>
<td>同步 truncate()</td>
</tr>
<tr>
<td>fs.chown(path, uid, gid, callback)</td>
<td>异步 chown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.chownSync(path, uid, gid)</td>
<td>同步 chown()</td>
</tr>
<tr>
<td>fs.fchown(fd, uid, gid, callback)</td>
<td>异步 fchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.fchownSync(fd, uid, gid)</td>
<td>同步 fchown()</td>
</tr>
<tr>
<td>fs.lchown(path, uid, gid, callback)</td>
<td>异步 lchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.lchownSync(path, uid, gid)</td>
<td>同步 lchown()</td>
</tr>
<tr>
<td>fs.chmod(path, mode, callback)</td>
<td>异步 chmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.chmodSync(path, mode)</td>
<td>同步 chmod().</td>
</tr>
<tr>
<td>fs.fchmod(fd, mode, callback)</td>
<td>异步 fchmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.fchmodSync(fd, mode)</td>
<td>同步 fchmod().</td>
</tr>
<tr>
<td>fs.lchmod(path, mode, callback)</td>
<td>异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.</td>
</tr>
<tr>
<td>fs.lchmodSync(path, mode)</td>
<td>同步 lchmod().</td>
</tr>
<tr>
<td>fs.stat(path, callback)</td>
<td>异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td>fs.lstat(path, callback)</td>
<td>异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td>fs.fstat(fd, callback)</td>
<td>异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td>fs.statSync(path)</td>
<td>同步 stat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td>fs.lstatSync(path)</td>
<td>同步 lstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td>fs.fstatSync(fd)</td>
<td>同步 fstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td>fs.link(srcpath, dstpath, callback)</td>
<td>异步 link().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.linkSync(srcpath, dstpath)</td>
<td>同步 link().</td>
</tr>
<tr>
<td>fs.symlink(srcpath, dstpath[, type], callback)</td>
<td>异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。</td>
</tr>
<tr>
<td>fs.symlinkSync(srcpath, dstpath[, type])</td>
<td>同步 symlink().</td>
</tr>
<tr>
<td>fs.readlink(path, callback)</td>
<td>异步 readlink(). 回调函数有两个参数 err, linkString。</td>
</tr>
<tr>
<td>fs.realpath(path[, cache], callback)</td>
<td>异步 realpath(). 回调函数有两个参数 err, resolvedPath。</td>
</tr>
<tr>
<td>fs.realpathSync(path[, cache])</td>
<td>同步 realpath()。返回绝对路径。</td>
</tr>
<tr>
<td>fs.unlink(path, callback)</td>
<td>异步 unlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.unlinkSync(path)</td>
<td>同步 unlink().</td>
</tr>
<tr>
<td>fs.rmdir(path, callback)</td>
<td>异步 rmdir().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.rmdirSync(path)</td>
<td>同步 rmdir().</td>
</tr>
<tr>
<td>fs.mkdir(path[, mode], callback)</td>
<td>S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。</td>
</tr>
<tr>
<td>fs.mkdirSync(path[, mode])</td>
<td>同步 mkdir().</td>
</tr>
<tr>
<td>fs.readdir(path, callback)</td>
<td>异步 readdir(3). 读取目录的内容。</td>
</tr>
<tr>
<td>fs.readdirSync(path)</td>
<td>同步 readdir().返回文件数组列表。</td>
</tr>
<tr>
<td>fs.close(fd, callback)</td>
<td>异步 close().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.closeSync(fd)</td>
<td>同步 close().</td>
</tr>
<tr>
<td>fs.open(path, flags[, mode], callback)</td>
<td>异步打开文件。</td>
</tr>
<tr>
<td>fs.openSync(path, flags[, mode])</td>
<td>同步fs.open().</td>
</tr>
<tr>
<td>fs.utimes(path, atime, mtime, callback)</td>
<td>修改文件时间戳，文件通过指定的文件路径。</td>
</tr>
<tr>
<td>fs.utimesSync(path, atime, mtime)</td>
<td>同步fs.utimes</td>
</tr>
<tr>
<td>fs.futimes(fd, atime, mtime, callback)</td>
<td>修改文件时间戳，通过文件描述符指定。</td>
</tr>
<tr>
<td>fs.futimesSync(fd, atime, mtime)</td>
<td>同步fs.futimes</td>
</tr>
<tr>
<td>fs.fsync(fd, callback)</td>
<td>异步 fsync.回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td>fs.fsyncSync(fd)</td>
<td>同步 fsync.</td>
</tr>
<tr>
<td>fs.write(fd, buffer, offset, length[, position], callback)</td>
<td>将缓冲区内容写入到通过文件描述符指定的文件。</td>
</tr>
<tr>
<td>fs.write(fd, data[, position[, encoding]], callback)</td>
<td>通过文件描述符 fd 写入文件内容。</td>
</tr>
<tr>
<td>fs.writeSync(fd, buffer, offset, length[, position])</td>
<td>同步版的 fs.write()。</td>
</tr>
<tr>
<td>fs.writeSync(fd, data[, position[, encoding]])</td>
<td>同步版的 fs.write().</td>
</tr>
<tr>
<td>fs.read(fd, buffer, offset, length, position, callback)</td>
<td>通过文件描述符 fd 读取文件内容。</td>
</tr>
<tr>
<td>fs.readSync(fd, buffer, offset, length, position)</td>
<td>同步版的 fs.read.</td>
</tr>
<tr>
<td>fs.readFile(filename[, options], callback)</td>
<td>异步读取文件内容。</td>
</tr>
<tr>
<td>fs.readFileSync(filename[, options])</td>
<td>同步的fs.readFile()</td>
</tr>
<tr>
<td>fs.writeFile(filename, data[, options], callback)</td>
<td>异步写入文件内容。</td>
</tr>
<tr>
<td>fs.writeFileSync(filename, data[, options])</td>
<td>同步版的 fs.writeFile。</td>
</tr>
<tr>
<td>fs.appendFile(filename, data[, options], callback)</td>
<td>异步追加文件内容。</td>
</tr>
<tr>
<td>fs.appendFileSync(filename, data[, options])</td>
<td>The 同步 version of fs.appendFile.</td>
</tr>
<tr>
<td>fs.watchFile(filename[, options], listener)</td>
<td>查看文件的修改。</td>
</tr>
<tr>
<td>fs.unwatchFile(filename[, listener])</td>
<td>停止查看 filename 的修改。</td>
</tr>
<tr>
<td>fs.watch(filename[, options][, listener])</td>
<td>查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。</td>
</tr>
<tr>
<td>fs.exists(path, callback)</td>
<td>检测给定的路径是否存在。</td>
</tr>
<tr>
<td>fs.existsSync(path)</td>
<td>同步版的 fs.exists.</td>
</tr>
<tr>
<td>fs.access(path[, mode], callback)</td>
<td>测试指定路径用户权限。</td>
</tr>
<tr>
<td>fs.accessSync(path[, mode])</td>
<td>同步版的 fs.access。</td>
</tr>
<tr>
<td>fs.createReadStream(path[, options])</td>
<td>返回ReadStream 对象。</td>
</tr>
<tr>
<td>fs.createWriteStream(path[, options])</td>
<td>返回 WriteStream 对象。</td>
</tr>
<tr>
<td>fs.symlink(srcpath, dstpath[, type], callback)</td>
<td>异步 symlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
</tbody>
</table>
</div></div></div></div></div><script type="text/javascript" src="js/node-base2.js"></script></body></html>